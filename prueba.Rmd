---
title: "Tarea Final EIB. Construcción Matriz de conteo"
author: "Pilar López Fernández"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette 
vignette: >
  %\VignetteIndexEntry{geod71810}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r,echo=FALSE}
doAll = FALSE
```
Creamos la matriz de expresión a partir de los ficheros de cuantificación obtenidos por HTSeqCount. 

Load R packages
```{r, warning=FALSE, message=FALSE}
library (edgeR)
library (PCAtools)
library(ggplot2)
library(DESeq2)
library(genefilter)
library(DEGreport)
library(AnnotationDbi)
library(org.Hs.eg.db)
```

# Contruimos la matriz de conteo!
En columnas, las muestras; en filas, los genes. También podemos leer los metadatos, que contiene la información sobre las muestras del experimento, que deberemos tener en cuenta para saber a qué grupo pertenecen. 
```{r}
#GSE175477
count.matrix.datos <- read.table(file = 'GSE175477genecounts2.csv',row.names = 1, sep = '\t', header = TRUE)
head(count.matrix.datos)
dim(count.matrix.datos)

metadata2 <- read.table("GSE175477conditions.csv",  sep = '\t',header=TRUE, stringsAsFactors=FALSE)
rownames(metadata2) <- metadata2$Sample_ID
head(metadata2)
```

```{r}
#GSE165322
count.matrix <- read.table(file = 'Gene165322genecounts2.csv',row.names = 1, sep = '\t', header = TRUE)
head(count.matrix)
dim(count.matrix)

metadata <- read.table("GSE165322_condition_factors.tsv",  sep = '\t',header=TRUE, stringsAsFactors=FALSE)
rownames(metadata) <- metadata$Sample_ID
head(metadata)

```

```{r}
#Podemos explorar la matriz de conteo:
class (count.matrix.datos)
dim (count.matrix.datos)
head(count.matrix.datos)
dim(count.matrix)
head(count.matrix)

#Leer la información de grupo
head(rownames(count.matrix.datos))

#rownames(count.matrix.datos) <- count.matrix.datos$gene_ID
head(count.matrix.datos)
summary(count.matrix.datos)
{barplot(colSums(count.matrix.datos>0),ylab="Number of detected genes GSE175477",las=2)
abline(h=median(colSums(count.matrix.datos>0)))}

head(rownames(count.matrix))
#rownames(count.matrix) <- count.matrix$geneID
head(count.matrix)
summary(count.matrix)
{barplot(colSums(count.matrix>0),ylab="Number of detected genes GSE165322",las=2)
abline(h=median(colSums(count.matrix>0)))}
```
Hemos creado un barplot para evaluar si descartamos alguna muestra, en base al número de genes detectados. Se ha representado con una linea la media de genes detectados en el total de las muestras.

También, podemos crear un boxplot para evaluar la distribución de los conteos. 
```{r}
boxplot(log10(as.matrix(count.matrix.datos)+1),ylab=expression('Log'[10]~'Read counts GSE175477'),las=2, main="Raw data")

boxplot(log10(as.matrix(count.matrix)+1),ylab=expression('Log'[10]~'Read counts GSE165322'),las=2, main="Raw data")
```



```{r,eval=doAll, message=FALSE, warning=FALSE, error=FALSE}
{barplot(colSums(count.matrix.datos>0),ylab="Number of detected genes GSE175477",las=2)
abline(h=median(colSums(count.matrix.datos>0)))}

{barplot(colSums(count.matrix>0),ylab="Number of detected genes GSE165322",las=2)
abline(h=median(colSums(count.matrix>0)))}
```

Representamos la **distribución por gen** mediante un histograma para evaluar en cuántas muestras tiene expresión un gen. 
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
n_samples2 <- rowSums(count.matrix.datos>0)
hist(n_samples2, xlab = "Number of samples", breaks=12)
n_samples <- rowSums(count.matrix>0)
hist(n_samples, xlab = "Number of samples", breaks=12)
```
# Filtramos los genes de menor expresión
Vamos a mantener los genes que poseen, como mínimo, 1 CPM (conteo por millón) en 4 o más muestras (estamos trabajado en ambos casos con 2 grupos de estudio de 6 muestras cada uno)
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
# remove genes with low counts
keep_genes2 <- rowSums(edgeR::cpm(count.matrix.datos)>1) >= 4
table(keep_genes2)
count.matrix.datos.filtered <- count.matrix.datos[keep_genes2,]
dim(count.matrix.datos.filtered)

keep_genes <- rowSums(edgeR::cpm(count.matrix)>1) >= 4
table(keep_genes)
count.matrix.filtered <- count.matrix[keep_genes,]
dim(count.matrix.filtered)
```
La nueva distribución de los conteos es:

```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
boxplot(log10(as.matrix(count.matrix.datos.filtered)+1),ylab=expression('Log'[10]~'Read counts'),las=2,
        main="Filtered data")

boxplot(log10(as.matrix(count.matrix.filtered)+1),ylab=expression('Log'[10]~'Read counts'),las=2,
        main="Filtered data")
```

# Normalización
## Mediante deseq2
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
metadata2$individual <- factor(metadata2$individual)
metadata$individual <- factor(metadata$individual)
```
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
datos2 <- DESeqDataSetFromMatrix(countData=count.matrix.datos.filtered, colData=metadata2, design=~individual)

datos <- DESeqDataSetFromMatrix(countData=count.matrix.filtered, colData=metadata, design=~individual)
```

```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
#GSE175477
# normalisation
datos2 <- DESeq2::estimateSizeFactors(datos2, type="ratio")
head(counts(datos2, normalized=FALSE))
head(counts(datos2, normalized=TRUE))
assay(datos2, "counts.norm") <- counts(datos2, normalized=TRUE)

#visualitation
par(mfrow=c(1,2))
boxplot(log10(as.matrix(assay(datos2, "counts")+1)),ylab=expression('Log'[10]~'Read counts'),las=2,main="Raw counts filtered")
boxplot(log10(as.matrix(assay(datos2, "counts.norm")+1)),ylab=expression('Log'[10]~'Read counts'),las=2,main="Median ratio normalization")
```

```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
#GSE165322
# normalisation
datos <- DESeq2::estimateSizeFactors(datos, type="ratio")
head(counts(datos, normalized=FALSE))
head(counts(datos, normalized=TRUE))
assay(datos, "counts.norm") <- counts(datos, normalized=TRUE)

#visualitation
par(mfrow=c(1,2))
boxplot(log10(as.matrix(assay(datos, "counts")+1)),ylab=expression('Log'[10]~'Read counts'),las=2,main="Raw counts filtered")
boxplot(log10(as.matrix(assay(datos, "counts.norm")+1)),ylab=expression('Log'[10]~'Read counts'),las=2,main="Median ratio normalization")
```

## Mediante VST

```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
assay(datos2, "counts2.norm.VST") = as.data.frame(assay(varianceStabilizingTransformation(datos2,blind=T)),check.names=F)

assay(datos, "counts.norm.VST") = as.data.frame(assay(varianceStabilizingTransformation(datos,blind=T)),check.names=F)
```

# Análisis exploratorio
## Análisis de correlación
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
library(pheatmap)
cor_matrix2 <- as.matrix(cor(assay(datos2, "counts2.norm.VST"),method="spearman"))

pheatmap(cor_matrix2,border_color=NA,annotation_col=metadata2[,"individual",drop=F],
         annotation_row=metadata2[,"individual",drop=F],annotation_legend=T)

cor_matrix <- as.matrix(cor(assay(datos, "counts.norm.VST"),method="spearman"))
colnames(count.matrix)
rownames(metadata)
head(metadata)
all.equal(colnames(count.matrix), rownames(metadata))
pheatmap(cor_matrix,border_color=NA,annotation_col=metadata[,"individual",drop=F],
         annotation_row=metadata[,"individual",drop=F],annotation_legend=T)
```

En la matriz, el color rojo denota mayor correlación (mayor similitud). 

## PCA

Realizamos PCA mediante la función 'prcomp()' de R. 
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
pcaobj2 <- prcomp(x=t(assay(datos2, "counts2.norm.VST")))
{barplot(round(pcaobj2$sdev^2/sum(pcaobj2$sdev^2)*100,2),las=2,
        names.arg=colnames(pcaobj2$x),ylab="% Variance explained",
        xlab="PCA principal components")
abline(h=2, lty=2)}

pcaobj <- prcomp(x=t(assay(datos, "counts.norm.VST")))
{barplot(round(pcaobj$sdev^2/sum(pcaobj$sdev^2)*100,2),las=2,
        names.arg=colnames(pcaobj$x),ylab="% Variance explained",
        xlab="PCA principal components")
abline(h=2, lty=2)}
```
Vemos que para GSE175477, PC1, PC2 y PC3 explican el 82% de la varianza (45%+19%+18%). Sin embargo, en GSE165322 solo PC1 y PC2 ya explican el 83% (75% + 9%). 

```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
library(sva) #Note this exercise requires sva (>= v3.36.0) which is only available for R (>= v4.x)
library(ggplot2)
library(gridExtra)
library(edgeR)

#GSE175477 -> PC1,PC2,PC3
pca_mat1.2 <- as.data.frame(pcaobj2$x)
pca_mat2.2 <- merge(pca_mat1.2,metadata2,by=0)

ggplot(pca_mat2.2,aes(PC1,PC2,colour=individual))+
  geom_point()+
  theme_bw()

p1 <- ggplot(pca_mat2.2,aes(PC1,PC3,colour=individual))+
  geom_point()+
  theme_bw()
p2 <- ggplot(pca_mat2.2,aes(PC2,PC3,colour=individual))+
  geom_point()+
  theme_bw()
gridExtra::grid.arrange(p1,p2,nrow=1,ncol=2)

#GSE165322 -> PC1,PC2
pca_mat1 <- as.data.frame(pcaobj$x)
pca_mat2 <- merge(pca_mat1,metadata,by=0)

ggplot(pca_mat2,aes(PC1,PC2,colour=individual))+
  geom_point()+
  theme_bw()
```
### Batch effect correction
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
class(datos)
head(cor_matrix)
#perform the batch correction

#first we need to transform the format of our groups and batches from names (e.g. "UHR", "HBR", etc.) to numbers (e.g. 1, 2, etc.)
datos.batch <- as.matrix(assay(datos))
head(datos.batch)
groups <- metadata$individual
batches <- metadata$seq_batch
datos.corrected = ComBat_seq(counts = datos.batch, batch = batches, group = groups)

dim(datos)
dim(datos.corrected)
head(datos.batch)
head(datos.corrected)
```

Repetimos PCA
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
datos <- DESeqDataSetFromMatrix(countData=datos.corrected, colData=metadata, design=~individual)
# normalisation
datos <- DESeq2::estimateSizeFactors(datos, type="ratio")
head(counts(datos, normalized=FALSE))
head(counts(datos, normalized=TRUE))
assay(datos, "counts.norm") <- counts(datos, normalized=TRUE)

#visualitation
par(mfrow=c(1,2))
boxplot(log10(as.matrix(assay(datos, "counts")+1)),ylab=expression('Log'[10]~'Read counts'),las=2,main="Raw counts filtered")
boxplot(log10(as.matrix(assay(datos, "counts.norm")+1)),ylab=expression('Log'[10]~'Read counts'),las=2,main="Median ratio normalization")

#Norm with VST
assay(datos, "counts.norm.VST") = as.data.frame(assay(varianceStabilizingTransformation(datos,blind=T)),check.names=F)

pcaobj.corrected <- prcomp(x=t(assay(datos, "counts.norm.VST")))
{barplot(round(pcaobj.corrected$sdev^2/sum(pcaobj.corrected$sdev^2)*100,2),las=2,
        names.arg=colnames(pcaobj.corrected$x),ylab="% Variance explained",
        xlab="PCA principal components")
abline(h=2, lty=2)}

pca_mat1 <- as.data.frame(pcaobj.corrected$x)
pca_mat2 <- merge(pca_mat1,metadata,by=0)

ggplot(pca_mat2,aes(PC1,PC2,colour=individual))+
  geom_point()+
  theme_bw()
```

## Clustering 
Se realiza una matriz de distancias muestra vs muestra. La distancia se computa mediante la función 'dist()' de R. 
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
dmat2 <- as.matrix(dist(t(assay(datos2, "counts2.norm.VST"))))

pheatmap(dmat2,border_color=NA,annotation_col=metadata[,"individual",drop=F],
         annotation_row=metadata[,"individual",drop=F],annotation_legend=T)

dmat <- as.matrix(dist(t(assay(datos, "counts.norm.VST"))))

pheatmap(dmat,border_color=NA,annotation_col=metadata[,"individual",drop=F],
         annotation_row=metadata[,"individual",drop=F],annotation_legend=T)
```


# Análisis de la expresión diferencial
Partimos de nuestros objetos DESeq2 creados anteriormente (datos y datos2). 
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
datos2 <- DESeq2::estimateDispersions(datos2)
```

```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
plotDispEsts(datos2)
```

```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
datos <- DESeq2::estimateDispersions(datos)
```

```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
plotDispEsts(datos)
```

The most commonly used testing for comparing two groups in DESeq2 is the Walds’s test. The null hypothesis is that the groups are not different and logFC=0. The list of contrasts can be seen using resultsNames(). Then we can pick our comparisons of interest.
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
dge_results2 <- nbinomWaldTest(datos2)
resultsNames(dge_results2)
#Obtenemos las tablas del contraste caso vs control
res1.2 <- results(dge_results2,name="individual_patient_vs_control",alpha=0.05, pAdjustMethod = "BH")
summary(res1.2)
head(res1.2)

#Distribución de los pvalores
hist(res1.2$pvalue[res1.2$baseMean>1],main="res1.2 Pval distribution",xlab="P-values")
```

```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
dge_results <- nbinomWaldTest(datos)
resultsNames(dge_results)
#Obtenemos las tablas del contraste caso vs control
res1 <- results(dge_results,name="individual_Patient_vs_Control",alpha=0.05, pAdjustMethod = "BH")
summary(res1)
head(res1)
class(res1) #objeto DESeqResults
#Distribución de los pvalores
hist(res1$pvalue[res1$baseMean>1],main="res1 Pval distribution",xlab="P-values")
```
Vemos un "mejor comportamiento" en los pvalores de GSE175477 que GSE165322. 

```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
dim(res1)
dim(res1.2)
# only genes with padj <0.05 and an absolute fold change >2
table(res1.2$padj<0.05 & abs(res1.2$log2FoldChange)>2)
table(res1$padj<0.05 & abs(res1$log2FoldChange)>2)
```
## Anotación
Vamos a hacer una pequeña anotación de los genes que conforman nuestra DGE list. 
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
# convert res to data.frame
df_res2 <- as.data.frame(res1.2)
head(df_res2)
head(res1.2)
# add row names as a new column
df_res2$gene_id <- rownames(df_res2)
head(df_res2)

# read genes info
hg2 <- read.delim("human_genes.csv",header=T,sep="\t",stringsAsFactors=F)
hg2 <- hg2[!duplicated(hg2$gene_id),]
head(hg2)
# merge dataframes
df_res22 <- merge(df_res2,hg2,by="gene_id")
head(df_res22)
```
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
# convert res to data.frame
df_res <- as.data.frame(res1)
# add row names as a new column
df_res$gene_id <- rownames(df_res)
head(df_res)

# read genes info
hg <- read.delim("human_genes.csv",header=T,sep="\t",stringsAsFactors=F)
hg <- hg[!duplicated(hg$gene_id),]
head(hg)
# merge dataframes
df_res11 <- merge(df_res,hg,by="gene_id")
head(df_res11)
```

Corregimos los valores logFC mediante 'lfcShrink()', que corrige el log2FC para genes con alta dispersión.
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
lres1.2 <- lfcShrink(dge_results2,coef="individual_patient_vs_control",res=res1.2,type="normal")
lres1.1 <- lfcShrink(dge_results,coef="individual_Patient_vs_Control",res=res1,type="normal")
```
## Visualización 
### MA plot
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
DESeq2::plotMA(res1.2, alpha=0.05, colNonSig = "gray60", colSig = "blue")
```
```{r,eval=doAll, results='hide', message=FALSE, warning=FALSE, error=FALSE}
DESeq2::plotMA(res1, alpha=0.05, colNonSig = "gray60", colSig = "blue")
```

### Volcano plot

## Exportamos los resultados
```{r}
head(df_res11)
head(df_res22)
#Para usar write.csv, dataframe solo
class(df_res11)
write.csv(df_res22, file = "resultsGSE175477.csv")
write.csv(df_res11, file = "resultsGSE165322.csv")
```
## Creamos un informe

```{r}
library(ReportingTools)
informe = "GSE175477 RESULTS"
inf = HTMLReport(shortName = informe, title = informe)
publish(df_res22,inf)
finish(inf)
```
```{r}
informe2 = "GSE165322 RESULTS"
inf2 = HTMLReport(shortName = informe2, title = informe2)
publish(df_res11,inf2)
finish(inf2)
```
# Análisis funcional
Partiendo de nuestra lista de DGE, se va a generar un GSA (gene set analysis), con el fin de obtener una perspectiva funcional integradora de los genes GO-biological process y rutas KEGG. 
```{r}
# only genes with padj <0.05 and an absolute fold change >2
# up and down-regulated genes
head(df_res22)
table(df_res22$padj<0.05 & abs(df_res22$log2FoldChange)>2)
table(df_res11$padj<0.05 & abs(df_res11$log2FoldChange)>2)

```


# Over-representation analysis (ORA)

&nbsp;
```{r}
#GSE175477
sig.genes2 = df_res22[df_res22$padj<0.05 & abs(df_res22$log2FoldChange)>3,]
head(sig.genes2)
# up and down-regulated genes
table(sig.genes2$log2FoldChange > 3)
table(sig.genes2$log2FoldChange < -3)
```

```{r}
#GSE165322
sig.genes = df_res11[df_res11$padj<0.05 & abs(df_res11$log2FoldChange)>3,]
# up and down-regulated genes
table(sig.genes$log2FoldChange > 3)
table(sig.genes$log2FoldChange < -3)
```

## Top genes

&nbsp;
### GSE175477
```{r ora top}
# Subset of up-regulated genes
threshold = 3   #hemos puesto un FC de 3; si ponemos menos, habrá más funciones significativas y viceversa.
top2 = sig.genes2[sig.genes2$log2FoldChange > threshold, ]
top_genes2 = top2$entrezgene

writeLines(as.character(top_genes2), con = "top_genes175477_list.txt", sep = "\n")
```

Mediante enrichGO() se hace el ORA (over-representation analysis)
```{r}
oraTop2 <- enrichGO(gene      = top_genes2,
                OrgDb         = org.Hs.eg.db,
                ont           = "BP",
                pAdjustMethod = "BH",
                minGSSize = 10,
                maxGSSize = 500,
                qvalueCutoff  = 0.05)

head(oraTop2)

dim(oraTop2)

barplot(oraTop2, showCategory = 10)
```


### GSE165322
```{r ora top}
# Subset of up-regulated genes
threshold = 2   #hemos puesto un FC de 3; si ponemos menos, habrá más funciones significativas y viceversa.
top = sig.genes[sig.genes$log2FoldChange > threshold, ]
head(top)
top_genes= top$entrezgene

writeLines(as.character(top_genes), con = "top_genes165322_list.txt", sep = "\n")
```

Mediante enrichGO() se hace el ORA (over-representation analysis)
```{r}
oraTop <- enrichGO(gene      = top_genes,
                OrgDb         = org.Hs.eg.db,
                ont           = "BP",
                pAdjustMethod = "BH",
                minGSSize = 10,
                maxGSSize = 500)

head(oraTop)

dim(oraTop)

barplot(oraTop, showCategory = 10)
```


## Bottom genes
### GSE175477
```{r}
# Subset of down-regulated genes
threshold = -3   #hemos puesto un FC de 3; si ponemos menos, habrá más funciones significativas y viceversa.
bottom2 = sig.genes2[sig.genes2$log2FoldChange < threshold, ]
bot_genes2= bottom2$entrezgene
head(bot_genes2)
writeLines(as.character(bot_genes2), con = "bot_genes175477_list.txt", sep = "\n")


oraBottom2 <- enrichGO(gene     = bot_genes2,
                 OrgDb         = org.Hs.eg.db,
                 ont           = "BP",
                 pAdjustMethod = "BH",
                 
                 minGSSize = 10,
                 maxGSSize = 500)
# save(oraBottom, file = "data/oraBottom.RData")
dim(oraBottom2)

dotplot(oraBottom2, showCategory = 10, x = "geneRatio")
```

### GSE165322
```{r}
# Subset of down-regulated genes
threshold = -3   #hemos puesto un FC de 3; si ponemos menos, habrá más funciones significativas y viceversa.
bottom = sig.genes[sig.genes$log2FoldChange < threshold, ]
bot_genes= bottom$entrezgene
head(bot_genes)
writeLines(as.character(bot_genes), con = "bot_genes165322_list.txt", sep = "\n")

oraBottom <- enrichGO(gene     = bot_genes,
                 OrgDb         = org.Hs.eg.db,
                 ont           = "BP",
                 pAdjustMethod = "BH",
                 
                 minGSSize = 10,
                 maxGSSize = 500)
# save(oraBottom, file = "data/oraBottom.RData")
dim(oraBottom)

dotplot(oraBottom, showCategory = 10, x = "geneRatio")
```



```{r, string package, fig.width=10}
# select specie
library(STRINGdb)
string_db = STRINGdb$new(version = "11.0b", species = 10116, 
                         score_threshold = 400)

# score_threshold default = 400

# map gene id to string id
head(top)
selection = top2[,  c("pvalue", "log2FoldChange", "gene_id", "entrezgene") ]
colnames(selection) = c("pvalue", "log2FoldChange", "gene_id", "entrezgene")
mapped <- suppressMessages(string_db$map(selection, "entrezgene", removeUnmappedRows = TRUE ))

hits = mapped$STRING_id[1:100]
head(hits)

string_db$plot_network(hits)
```


## GO enrichment analysis
GO se compone de tres ontologias: MF (molecular function), BP (biological process), CC (celular component). Podemos usar el dataset 'geneList' proporcionado por [DOSE](http://bioconductor.org/packages/release/bioc/html/DOSE.html).  
```{r}
library(clusterProfiler)
head(df_res11)
data(geneList, package="DOSE")
gene <- names(geneList)[abs(geneList) > 2]

# Entrez gene ID
head(gene)
```
```{r}
ggo <- groupGO(gene     = gene,
               OrgDb    = org.Hs.eg.db,
               ont      = "CC",
               level    = 3,
               readable = TRUE)

head(ggo)
```
Mediante enrichGO() se hace el ORA (over-representation analysis)
```{r}
ego <- enrichGO(gene          = gene,
                universe      = names(geneList),
                OrgDb         = org.Hs.eg.db,
                ont           = "BP",
                pAdjustMethod = "BH",
                minGSSize = 10,    #se filtran las funciones que tengan entre 10 y 500 funciones.
                maxGSSize = 500,
                qvalueCutoff  = 0.05,
                readable      = TRUE)
head(ego)
```


